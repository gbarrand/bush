<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>&lt;h1&gt;Prerequisites&lt;/h1&gt;</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.8.20 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title"><h1>Prerequisites</h1>
</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="bush_prerequisites_linux"></a>
Linux</h1>
<p>You need : </p><pre class="fragment"> - a C++ compiler: g++ or clang++. In bush/use_cc, use_cpp, the default uses g++ for Linux.
   If having to tweak things, you have to follow the ${build_gnu} or ${build_clang}
   usage in these scripts and customize what is found within the corresponding "if".
 - zip to build the final binary kit file, but if not here tar is used.
 - ar, ranlib.
 - for graphics apps (most of them!), the X11 and OpenGL "devels" to have the .h headers files.
   (In general the run time .so shared libraries are already here).
</pre><p> and... that's all (folks). On most Linux distributions g++, zip, ar, ranlib, X11 and OpenGL are here. If not, install them with "sudo apt-get..." or "sudo yum..." according your Linux distribution, for example with something as: </p><pre class="fragment">    ubuntu&gt; sudo apt-get install libglu1-mesa-dev  # to have OpenGL .h.
 or on centos7:
    centos&gt; sudo yum install gcc gcc-c++
    centos&gt; sudo yum install zip unzip
    centos&gt; sudo yum install libX11-devel libXpm-devel libXft-devel libXext-devel
    centos&gt; sudo yum install mesa-libGL-devel mesa-libGLU-devel
</pre><h1><a class="anchor" id="bush_prerequisites_macOS"></a>
macOS</h1>
<p>In bush/use_cc, use_cpp, the default built for apps is to build with Cocoa, then the compiler (clang++) and Cocoa access (under /Applications/Xcode.app/Contents/...) uses the one of a Xcode installation, then you have to install Xcode and the "Xcode command line tools" to build. If having to tweak things, you have to act within the "if" for ${buidl_sdk_mac} or ${build_sdk_mac_gnu}.</p>
<p>Note that if building a non Cocoa app (for example the X11 version of the pmx application), it is the build with clang (${build_clang}) which is used. </p><pre class="fragment">    macOS&gt; cd &lt;some_path&gt;/pmx/mgr
    macOS&gt; ./build  # it uses clang++ and put binaries in bin_sdk_mac.
    macOS&gt; open ./bin_sdk_mac/distrib/pmx/&lt;verions&gt;/pmx.app  # to run the Cocoa version.
    macOS&gt; ./build -x11 -bin_x11  # it uses clang++.
    macOS&gt; ./bin_x11/distrib/pmx/&lt;verions&gt;/bin/pmx  # to run the X11 version.
 or:
    macOS&gt; cd &lt;some_path&gt;/inlib/examples/cpp
    macOS&gt; ./build wroot.cpp
    macOS&gt; ./bin_clang/wroot
 or:
    macOS&gt; cd &lt;some_path&gt;/exlib/examples/cpp
    macOS&gt; ./build GL_X11.cpp
    macOS&gt; ./bin_clang/GL_X11
</pre><h1><a class="anchor" id="bush_prerequisites_windows"></a>
Windows-10</h1>
<p>On Windows-10 we build with VisualC++ (cl.exe) from a cygwin prompt. VisualC++ is mendatory since, by default, we do the graphics of our apps with the Microsoft WIN32 libs (in particular opengl32.lib). Stricly speaking our apps may be built by using the cygwin g++ and X11 libs, but this would need to pass by a local X11 server and would be clearly less performant than being "straight Microsoft". (Moreover the cygwin/g++ is known to be a snail compared to VisualC++). (We did not tried to use a clang++ coming from cygwin).</p>
<p>Then you need: </p><pre class="fragment"> - Visual Studio. We use the 2015 one.
 - cygwin with at least zip (bash is here by default). We installed git (to get code)
   and openssh (to log in and out to remote machines), and... it must be all.
</pre><p> If having to tweak bush/use_cc, use_cpp follow ${build_visual}. Note that the access to cl.exe to compile and the Visual link.exe to link is concentrated in the script bush/vc++. In particular all other build scripts (for example bush/compile_one_cpp) uses bush/vc++ with the same options than g++ and clang++ to declare include paths (-I), link path (-L), etc... The script bush/vc++ translates these to the /I, /L known by cl.exe, link.exe and does also the job to translate cygwin unix paths to Windows paths.</p>
<p>IMPORTANT : bush/vc++ assumes that "cl.exe" is in your PATH, then that the "vcvars.bat" of VisualC++ had been executed. (vcvars is a DOS script that setup the environment of VisualC++). Then to work, the procedure is something as : </p><pre class="fragment"> - install Visual Studio.
 - create a command line window DOS prompt by arranging to run the Windows cmd.exe program.
 - from here, arrange to "CALL VCVARS.BAT" of VisualC++. It should be somewhere under the C:\Program files
   directory where VisualStudio is installed.
 - from the same DOS prompt, launch cygwin. Then from the cygwin bash prompt, typing cl.exe should do something.
 - from the cygwin prompt you can start to build some app by using bush.
</pre><p>(Note that there is a falltrap with "link.exe" which exists as a VisualStudio program to link an application and a cygiwn program found under /usr/bin. It is the one of Visual that should be used. The bush/find_link_exe script is used by bush/vc++ to find the Visual one. You may have to customize it to find the link.exe under your VisualC++ installation).</p>
<h2><a class="anchor" id="bush_prerequisites_getline"></a>
Programs that use Getline to enter commands</h2>
<p>Programs, as gopaw, that use Getline to enter commands from the terminal, must be launched from a cmd.exe command line DOS window, and not from the cygwin prompt. Getline does not work if the program is started from a cgywin prompt. Then this goes for gopaw but also for apps that had been built to be able to receive commands (as insh ones) from the terminal and started with the "-terminal" option. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->

</body>
</html>
